// Generated by delombok at Thu Mar 16 15:46:21 EDT 2023
/*
 * Table Wrapper API
 * Copyright (C) 2020  Spacious Team <spacious-team@ya.ru>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package org.spacious_team.table_wrapper.api;

import org.checkerframework.checker.nullness.qual.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import static java.util.Collections.unmodifiableMap;
import static java.util.Objects.requireNonNull;

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.KeyForSubchecker")
public abstract class AbstractTable<R extends ReportPageRow> implements Table {

    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(AbstractTable.class);

    protected final  AbstractReportPage<R> reportPage;

    protected final  String tableName;

    private final  TableCellRange tableRange;

    private final  Map<TableColumn, Integer> headerDescription;

    private final   boolean empty;

    /**
     * Offset of first data row. First table row is a header.
     */
    private final   int dataRowOffset;

    /**
     * @param tableRange only first and last row numbers matters
     */
    protected <T extends Enum<T> & TableHeaderColumn> AbstractTable(AbstractReportPage<R> reportPage, String tableName, TableCellRange tableRange, Class<T> headerDescription, int headersRowCount) {
        this.reportPage = reportPage;
        this.tableName = tableName;
        // table_name + headersRowCount
        this.dataRowOffset = 1 + headersRowCount;
        this.empty = isEmpty(tableRange, dataRowOffset);
        this.headerDescription = this.empty ? Collections.emptyMap() : getHeaderDescription(reportPage, tableRange, headerDescription, headersRowCount);
        this.tableRange = empty ? tableRange : TableCellRange.of(tableRange.getFirstRow(), tableRange.getLastRow(), getColumnIndices(this.headerDescription).min().orElse(tableRange.getFirstColumn()), getColumnIndices(this.headerDescription).max().orElse(tableRange.getLastColumn()));
    }

    protected AbstractTable(AbstractTable<R> table, int appendDataRowsToTop, int appendDataRowsToBottom) {
        this.reportPage = table.reportPage;
        this.tableName = table.tableName;
        this.tableRange = table.tableRange.addRowsToTop(appendDataRowsToTop).addRowsToBottom(appendDataRowsToBottom);
        this.dataRowOffset = table.dataRowOffset;
        this.empty = isEmpty(tableRange, dataRowOffset);
        this.headerDescription = table.headerDescription;
    }

    @org.checkerframework.dataflow.qual.Pure
    private static   boolean isEmpty( TableCellRange tableRange,   int dataRowOffset) {
        return getNumberOfTableRows(tableRange) <= dataRowOffset;
    }

    @org.checkerframework.dataflow.qual.Pure
    private static   int getNumberOfTableRows( TableCellRange tableRange) {
        return tableRange.getLastRow() - tableRange.getFirstRow() + 1;
    }

    private static <T extends Enum<T> & TableHeaderColumn>  Map<TableColumn, Integer> getHeaderDescription( AbstractReportPage<?> reportPage,  TableCellRange tableRange,  Class<T> headerDescription,   int headersRowCount) {
        Map<TableColumn, Integer> columnIndices = new HashMap<>();
        ReportPageRow[] headerRows = new ReportPageRow[headersRowCount];
        for (int i = 0; i < headersRowCount; i++) {
            ReportPageRow row = reportPage.getRow(tableRange.getFirstRow() + 1 + i);
            ReportPageRow notNullRow = requireNonNull(row, "Header row is absent");
            headerRows[i] = notNullRow;
        }
        TableColumn[] columns = Arrays.stream(headerDescription.getEnumConstants()).map(TableHeaderColumn::getColumn).toArray(TableColumn[]::new);
        for (TableColumn column : columns) {
            try {
                int columnIndex = column.getColumnIndex(headerRows);
                columnIndices.put(column, columnIndex);
            } catch (OptionalTableColumnNotFound e) {
                log.debug("Optional header column is not found: {}", column, e);
            }
        }
        return unmodifiableMap(columnIndices);
    }

    private static  IntStream getColumnIndices( Map<TableColumn, Integer> headerDescription) {
        return headerDescription.values().stream().mapToInt(i -> i);
    }

    public <T>  List<T> getData( AbstractTable<R> this,  Object report,  Function<TableRow, T> rowExtractor) {
        return getDataCollection(report, (row, data) -> {
            T result = rowExtractor.apply(row);
            if (result != null) {
                data.add(result);
            }
        });
    }

    public <T>  List<T> getDataCollection( AbstractTable<R> this,  Object report,  Function<TableRow, Collection<T>> rowExtractor) {
        return getDataCollection(report, (row, data) -> {
            Collection<T> result = rowExtractor.apply(row);
            if (result != null) {
                data.addAll(result);
            }
        });
    }

    public <T>  List<T> getDataCollection( AbstractTable<R> this,  Object report,  Function<TableRow, Collection<T>> rowExtractor,  BiPredicate<T, T> equalityChecker,  BiFunction<T, T, Collection<T>> mergeDuplicates) {
        return getDataCollection(report, (row, data) -> {
            Collection<T> result = rowExtractor.apply(row);
            if (result != null) {
                for (T r : result) {
                    addWithEqualityChecker(r, data, equalityChecker, mergeDuplicates);
                }
            }
        });
    }

    private <T>  List<T> getDataCollection( AbstractTable<R> this,  Object report,  BiConsumer<TableRow, Collection<T>> rowHandler) {
        List<T> data = new ArrayList<>();
        for (TableRow row : this) {
            if (row != null) {
                try {
                    rowHandler.accept(row, data);
                } catch (Exception e) {
                    log.warn("Не могу распарсить таблицу \'{}\' в {}, строка {}", tableName, report, row.getRowNum() + 1, e);
                }
            }
        }
        return data;
    }

    public static <T> void addWithEqualityChecker(T element,  Collection<T> collection,  BiPredicate<T, T> equalityChecker,  BiFunction<T, T, Collection<T>> duplicatesMerger) {
        T equalsObject = null;
        for (T e : collection) {
            if (equalityChecker.test(e, element)) {
                equalsObject = e;
                break;
            }
        }
        if (equalsObject != null) {
            collection.remove(equalsObject);
            Collection<T> mergedCollection = duplicatesMerger.apply(equalsObject, element);
            if (mergedCollection != null) {
                collection.addAll(mergedCollection);
            }
        } else {
            collection.add(element);
        }
    }

    /**
     * {@link TableRow} impl is mutable.
     * For performance issue same object with changed state is provided in each loop cycle.
     * Call {@link TableRow#clone()} if you want to use row object outside stream() block.
     */
    public  Stream<TableRow> stream( AbstractTable<R> this) {
        return StreamSupport.stream(spliterator(), false);
    }

    /**
     * Iterator which returns {@link MutableTableRow} or {@link EmptyTableRow}.
     *
     * @implSpec This iterator never returns null values. Null rows is wrapped by {@link EmptyTableRow}
     * @implNote For performance issue same object with changed state is provided in each loop cycle.
     * Call {@link TableRow#clone()} if you want to use row object outside iterator() block.
     */
    public  Iterator<TableRow> iterator( AbstractTable<R> this) {
        return new TableIterator();
    }

    protected class TableIterator implements Iterator<TableRow> {

        private final  MutableTableRow<R> tableRow = new MutableTableRow<>(AbstractTable.this, getCellDataAccessObject());

        private final   int numberOfRows = getNumberOfTableRows(tableRange);

        private   int i = dataRowOffset;

        @org.checkerframework.dataflow.qual.Pure
        public   boolean hasNext( TableIterator this) {
            return i < numberOfRows;
        }

        /**
         * Returns mutable {@link TableRow} impl. Never returns null value.
         */
        public  TableRow next( TableIterator this) {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            int rowNum = tableRange.getFirstRow() + (i++);
            R row = getRow(rowNum);
            if (row == null) {
                return new EmptyTableRow(AbstractTable.this, rowNum);
            }
            tableRow.setRow(row);
            return tableRow;
        }
    }

    @org.checkerframework.dataflow.qual.Pure
    public R getRow( AbstractTable<R> this,   int i) {
        return reportPage.getRow(i);
    }

    public  TableRow findRow( AbstractTable<R> this,  Object value) {
        TableCellAddress address = reportPage.find(value);
        return getMutableTableRow(address);
    }

    public  TableRow findRowByPrefix( AbstractTable<R> this,  String prefix) {
        TableCellAddress address = reportPage.findByPrefix(prefix);
        return getMutableTableRow(address);
    }

    private  MutableTableRow<R> getMutableTableRow( AbstractTable<R> this,  TableCellAddress address) {
        if (tableRange.contains(address)) {
            MutableTableRow<R> tableRow = new MutableTableRow<>(this, getCellDataAccessObject());
            R row = requireNonNull(getRow(address.getRow()), "Row is empty");
            tableRow.setRow(row);
            return tableRow;
        }
        return null;
    }

    @org.checkerframework.dataflow.qual.Pure
    protected abstract CellDataAccessObject<?, R> getCellDataAccessObject( AbstractTable<R> this);

    @org.checkerframework.dataflow.qual.Pure
    public boolean equals(final java.lang.Object o) {
        if (o == this)
            return true;
        if (!(o instanceof AbstractTable))
            return false;
        final AbstractTable<?> other = (AbstractTable<?>) o;
        if (!other.canEqual((java.lang.Object) this))
            return false;
        if (this.isEmpty() != other.isEmpty())
            return false;
        if (this.dataRowOffset != other.dataRowOffset)
            return false;
        final java.lang.Object this$reportPage = this.getReportPage();
        final java.lang.Object other$reportPage = other.getReportPage();
        if (this$reportPage == null ? other$reportPage != null : !this$reportPage.equals(other$reportPage))
            return false;
        final java.lang.Object this$tableName = this.tableName;
        final java.lang.Object other$tableName = other.tableName;
        if (this$tableName == null ? other$tableName != null : !this$tableName.equals(other$tableName))
            return false;
        final java.lang.Object this$tableRange = this.getTableRange();
        final java.lang.Object other$tableRange = other.getTableRange();
        if (this$tableRange == null ? other$tableRange != null : !this$tableRange.equals(other$tableRange))
            return false;
        final java.lang.Object this$headerDescription = this.getHeaderDescription();
        final java.lang.Object other$headerDescription = other.getHeaderDescription();
        if (this$headerDescription == null ? other$headerDescription != null : !this$headerDescription.equals(other$headerDescription))
            return false;
        return true;
    }

    @org.checkerframework.dataflow.qual.Pure
    protected boolean canEqual(final java.lang.Object other) {
        return other instanceof AbstractTable;
    }

    @org.checkerframework.dataflow.qual.Pure
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        result = result * PRIME + (this.isEmpty() ? 79 : 97);
        result = result * PRIME + this.dataRowOffset;
        final java.lang.Object $reportPage = this.getReportPage();
        result = result * PRIME + ($reportPage == null ? 43 : $reportPage.hashCode());
        final java.lang.Object $tableName = this.tableName;
        result = result * PRIME + ($tableName == null ? 43 : $tableName.hashCode());
        final java.lang.Object $tableRange = this.getTableRange();
        result = result * PRIME + ($tableRange == null ? 43 : $tableRange.hashCode());
        final java.lang.Object $headerDescription = this.getHeaderDescription();
        result = result * PRIME + ($headerDescription == null ? 43 : $headerDescription.hashCode());
        return result;
    }

    @org.checkerframework.dataflow.qual.Pure
    public java.lang.String toString() {
        return "AbstractTable(tableName=" + this.tableName + ")";
    }

    @org.checkerframework.dataflow.qual.Pure
    public AbstractReportPage<R> getReportPage() {
        return this.reportPage;
    }

    @org.checkerframework.dataflow.qual.Pure
    public TableCellRange getTableRange() {
        return this.tableRange;
    }

    @org.checkerframework.dataflow.qual.Pure
    public Map<TableColumn, Integer> getHeaderDescription() {
        return this.headerDescription;
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean isEmpty() {
        return this.empty;
    }
}
